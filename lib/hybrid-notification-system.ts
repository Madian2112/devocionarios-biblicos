// üéØ SISTEMA H√çBRIDO DE NOTIFICACIONES
// üìß Emails (Brevo) para casos importantes + üì± Notificaciones nativas para recordatorios

import { BrevoEmailService } from './brevo-email-service';
import { nativeNotificationSystem } from './native-notification-system';

interface WelcomeData {
  userName: string;
  userEmail: string;
}

interface UserStats {
  streak: number;
  completedThisWeek: number;
  totalDevocionales: number;
  totalStudies: number;
}

interface NotificationPreferences {
  emailEnabled: boolean;
  nativeEnabled: boolean;
  dailyReminder: boolean;
  streakReminder: boolean;
  weeklyReport: boolean;
  reminderTime: string;
}

export class HybridNotificationSystem {
  private static instance: HybridNotificationSystem;
  
  static getInstance(): HybridNotificationSystem {
    if (!HybridNotificationSystem.instance) {
      HybridNotificationSystem.instance = new HybridNotificationSystem();
    }
    return HybridNotificationSystem.instance;
  }

  /**
   * üöÄ Inicializar sistema h√≠brido completo
   */
  async initialize(userName: string, userEmail: string): Promise<{
    emailReady: boolean;
    nativeReady: boolean;
  }> {
    console.log('üöÄ Inicializando sistema h√≠brido de notificaciones...');

    try {
      // Inicializar sistema nativo (paralelo)
      const nativeReady = await nativeNotificationSystem.initialize(userName);
      
      // Email siempre est√° listo con Brevo (no requiere inicializaci√≥n)
      const emailReady = true;
      
      console.log('‚úÖ Sistema h√≠brido inicializado:', { emailReady, nativeReady });
      
      return { emailReady, nativeReady };
      
    } catch (error) {
      console.error('‚ùå Error inicializando sistema h√≠brido:', error);
      return { emailReady: false, nativeReady: false };
    }
  }

  /**
   * üéâ BIENVENIDA COMPLETA (Email + Notificaci√≥n)
   */
  async sendWelcome(data: WelcomeData): Promise<{
    emailSent: boolean;
    notificationShown: boolean;
  }> {
    console.log('üéâ Enviando bienvenida h√≠brida...');

    // üìß Email de bienvenida (Brevo) - IMPORTANTE, debe persistir
    const emailPromise = BrevoEmailService.sendWelcomeEmail(data)
      .catch(error => {
        console.error('‚ùå Error email bienvenida:', error);
        return false;
      });

    // üì± Notificaci√≥n nativa - Para engagement inmediato
    const notificationPromise = nativeNotificationSystem.requestPermission()
      .catch(error => {
        console.error('‚ùå Error notificaci√≥n bienvenida:', error);
        return false;
      });

    // Ejecutar en paralelo para m√°xima velocidad
    const [emailSent, notificationShown] = await Promise.all([
      emailPromise,
      notificationPromise
    ]);

    console.log('üéâ Bienvenida h√≠brida completada:', { emailSent, notificationShown });
    
    return { emailSent, notificationShown };
  }

  /**
   * üîë RESET PASSWORD (Email personalizado complementario)
   */
  async sendPasswordReset(userEmail: string): Promise<boolean> {
    console.log('üîë Enviando email personalizado de reset password...');
    
    try {
      // Usar nueva funci√≥n espec√≠fica de reset password en Brevo
      const emailSent = await BrevoEmailService.sendPasswordResetEmail({
        userEmail: userEmail
      });

      if (emailSent) {
        console.log('‚úÖ Email personalizado de reset password enviado');
      } else {
        console.log('‚ö†Ô∏è Error enviando email personalizado de reset password');
      }

      return emailSent;

    } catch (error) {
      console.error('‚ùå Error en reset password personalizado:', error);
      return false;
    }
  }

  /**
   * üôè RECORDATORIO DIARIO (Solo Notificaci√≥n Nativa)
   */
  async sendDailyReminder(): Promise<boolean> {
    console.log('üôè Enviando recordatorio diario...');
    
    try {
      // Solo notificaci√≥n nativa - para engagement inmediato
      const sent = await nativeNotificationSystem.showDailyReminder();
      
      if (sent) {
        console.log('‚úÖ Recordatorio diario enviado');
      } else {
        console.log('‚ö†Ô∏è No se pudo enviar recordatorio diario');
      }

      return sent;

    } catch (error) {
      console.error('‚ùå Error enviando recordatorio diario:', error);
      return false;
    }
  }

  /**
   * üî• RECORDATORIO DE RACHA (Solo Notificaci√≥n Nativa)
   */
  async sendStreakReminder(stats: UserStats): Promise<boolean> {
    console.log('üî• Enviando recordatorio de racha...');
    
    try {
      // Solo notificaci√≥n nativa - para engagement inmediato
      const sent = await nativeNotificationSystem.showStreakReminder(stats);
      
      if (sent) {
        console.log('‚úÖ Recordatorio de racha enviado');
      } else {
        console.log('‚ö†Ô∏è No se pudo enviar recordatorio de racha');
      }

      return sent;

    } catch (error) {
      console.error('‚ùå Error enviando recordatorio de racha:', error);
      return false;
    }
  }

  /**
   * üìä REPORTE SEMANAL (Ambos - Email + Notificaci√≥n)
   */
  async sendWeeklyReport(data: WelcomeData & UserStats): Promise<{
    emailSent: boolean;
    notificationShown: boolean;
  }> {
    console.log('üìä Enviando reporte semanal h√≠brido...');

    // üìß Email detallado (persistente, se puede revisar despu√©s)
    const emailData = {
      ...data,
      completed: data.completedThisWeek // Mapear correctamente
    };
    
    const emailPromise = BrevoEmailService.sendWelcomeEmail(emailData) // Por ahora usar sendWelcomeEmail
      .catch(error => {
        console.error('‚ùå Error email reporte:', error);
        return false;
      });

    // üì± Notificaci√≥n nativa (engagement inmediato)
    const notificationPromise = nativeNotificationSystem.showWeeklyReport(data)
      .catch(error => {
        console.error('‚ùå Error notificaci√≥n reporte:', error);
        return false;
      });

    // Ejecutar en paralelo
    const [emailSent, notificationShown] = await Promise.all([
      emailPromise,
      notificationPromise
    ]);

    console.log('üìä Reporte semanal h√≠brido completado:', { emailSent, notificationShown });
    
    return { emailSent, notificationShown };
  }

  /**
   * ‚öôÔ∏è CONFIGURAR PREFERENCIAS
   */
  async configurePreferences(prefs: NotificationPreferences): Promise<boolean> {
    console.log('‚öôÔ∏è Configurando preferencias h√≠bridas:', prefs);

    try {
      // Configurar sistema nativo
      if (prefs.nativeEnabled) {
        nativeNotificationSystem.saveConfig({
          enabled: prefs.nativeEnabled,
          dailyReminder: prefs.dailyReminder,
          streakReminder: prefs.streakReminder,
          weeklyReport: prefs.weeklyReport,
          time: prefs.reminderTime,
          customVerse: true
        });

        // Programar notificaciones
        nativeNotificationSystem.scheduleNotifications();
      }

      // Guardar preferencias h√≠bridas
      localStorage.setItem('hybrid-notification-prefs', JSON.stringify(prefs));
      
      console.log('‚úÖ Preferencias h√≠bridas configuradas');
      return true;

    } catch (error) {
      console.error('‚ùå Error configurando preferencias:', error);
      return false;
    }
  }

  /**
   * üìñ CARGAR PREFERENCIAS
   */
  getPreferences(): NotificationPreferences {
    try {
      const saved = localStorage.getItem('hybrid-notification-prefs');
      if (saved) {
        return JSON.parse(saved);
      }
    } catch (error) {
      console.error('‚ùå Error cargando preferencias:', error);
    }

    // Valores por defecto
    return {
      emailEnabled: true,
      nativeEnabled: true,
      dailyReminder: true,
      streakReminder: true,
      weeklyReport: true,
      reminderTime: '19:00'
    };
  }

  /**
   * üß™ ENVIAR NOTIFICACIONES DE PRUEBA
   */
  async sendTestNotifications(data: WelcomeData): Promise<{
    emailSent: boolean;
    notificationShown: boolean;
  }> {
    console.log('üß™ Enviando notificaciones de prueba...');

    // üìß Email de prueba
    const emailPromise = BrevoEmailService.sendWelcomeEmail({
      ...data,
      userName: `${data.userName} (Prueba)`
    }).catch(() => false);

    // üì± Notificaci√≥n de prueba
    const notificationPromise = nativeNotificationSystem.sendTestNotification()
      .catch(() => false);

    const [emailSent, notificationShown] = await Promise.all([
      emailPromise,
      notificationPromise
    ]);

    console.log('üß™ Pruebas completadas:', { emailSent, notificationShown });
    
    return { emailSent, notificationShown };
  }

  /**
   * üìä OBTENER ESTADO DEL SISTEMA
   */
  getSystemStatus(): {
    email: {
      service: string;
      available: boolean;
    };
    native: {
      supported: boolean;
      permission: NotificationPermission;
      serviceWorkerReady: boolean;
    };
    preferences: NotificationPreferences;
  } {
    const nativeStats = nativeNotificationSystem.getStats();
    
    return {
      email: {
        service: 'Brevo',
        available: true // Brevo siempre disponible
      },
      native: {
        supported: nativeStats.supported,
        permission: nativeStats.permission,
        serviceWorkerReady: nativeStats.serviceWorkerReady
      },
      preferences: this.getPreferences()
    };
  }

  /**
   * üîÑ INICIALIZAR RECORDATORIOS AUTOM√ÅTICOS
   */
  startAutomaticReminders(): void {
    console.log('üîÑ Iniciando recordatorios autom√°ticos...');
    
    const prefs = this.getPreferences();
    
    if (prefs.nativeEnabled) {
      nativeNotificationSystem.scheduleNotifications();
      console.log('‚úÖ Recordatorios autom√°ticos iniciados');
    } else {
      console.log('üìµ Recordatorios autom√°ticos deshabilitados');
    }
  }

  /**
   * üõë DETENER RECORDATORIOS AUTOM√ÅTICOS
   */
  stopAutomaticReminders(): void {
    console.log('üõë Deteniendo recordatorios autom√°ticos...');
    
    // Deshabilitar notificaciones nativas
    nativeNotificationSystem.saveConfig({
      enabled: false,
      dailyReminder: false,
      streakReminder: false,
      weeklyReport: false,
      time: '19:00',
      customVerse: true
    });
    
    console.log('‚úÖ Recordatorios autom√°ticos detenidos');
  }
}

// üåü Exportar instancia singleton
export const hybridNotificationSystem = HybridNotificationSystem.getInstance();

/**
 * üéØ ESTRATEGIA H√çBRIDA PERFECTA:
 * 
 * üìß EMAILS (BREVO) PARA:
 * ‚úÖ Bienvenida - Mensaje importante que debe persistir
 * ‚úÖ Reset Password - Cr√≠tico, debe ser confiable
 * ‚úÖ Reportes semanales - Informaci√≥n detallada para revisar
 * ‚úÖ Notificaciones especiales - Ocasionales e importantes
 * 
 * üì± NOTIFICACIONES NATIVAS PARA:
 * ‚úÖ Recordatorios diarios - Engagement inmediato
 * ‚úÖ Recordatorios de racha - Motivaci√≥n en tiempo real
 * ‚úÖ Alertas de progreso - Feedback instant√°neo
 * ‚úÖ Todo lo que requiere acci√≥n inmediata
 * 
 * üí° BENEFICIOS DE ESTA ESTRATEGIA:
 * 
 * üéØ M√°ximo engagement con notificaciones nativas
 * üìß Persistencia con emails importantes
 * üí∞ 100% gratis para ambos sistemas
 * ‚ö° Paralelo = m√°xima velocidad
 * üîß Control total del comportamiento
 * üìä Estad√≠sticas completas
 * üöÄ Escalable y mantenible
 * 
 * üî• EL MEJOR DE AMBOS MUNDOS! üî•
 */ 